<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Scene with OBJ Models</title>
    <!-- Include Three.js core library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    
    <!-- Use UNPKG CDN for OBJLoader and MTLLoader -->
    <script src="https://unpkg.com/three@0.154.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://unpkg.com/three@0.154.0/examples/js/loaders/MTLLoader.js"></script>

    <!-- Include Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js?8.0"></script>
    
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        // Check if we are in Telegram Web App environment
        if (window.Telegram && window.Telegram.WebApp) {
            console.log("Telegram Web App detected.");

            // Request fullscreen only in Telegram Web App (if supported)
            try {
                window.Telegram.WebApp.requestFullscreen();
            } catch (error) {
                console.log("Fullscreen request failed: " + error.message);
            }

            // Set header color for Telegram Web App
            window.Telegram.WebApp.setHeaderColor("#000000");
        } else {
            console.log("Browser environment detected. No fullscreen request.");
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add space background (skybox)
        const textureLoader = new THREE.TextureLoader();
        const spaceTexture = textureLoader.load('space_texture.jpg'); // Replace with your own space texture
        scene.background = spaceTexture;

        // Lighting
        const light = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(light);

        // Load OBJ model with MTL material (for .obj and .mtl files)
        const objLoader = new THREE.OBJLoader();
        const mtlLoader = new THREE.MTLLoader();

        mtlLoader.load('VulcanDKyrClass.mtl', function(materials) {
            materials.preload();  // Preload materials
            objLoader.setMaterials(materials);
            objLoader.load('VulcanDKyrClass.obj', function(object) {
                object.scale.set(0.5, 0.5, 0.5); // Adjust scale
                object.position.set(0, 0, -5); // Position the object
                scene.add(object);

                // Trigger explosion after 5 seconds
                setTimeout(() => {
                    explodeModel(object); // Trigger explosion after 5 seconds
                }, 5000);
            });
        });

        // Explosion animation function
        function explodeModel(model) {
            const explosionDuration = 2; // Time in seconds
            const scaleFactor = 3; // How much the object scales during explosion

            // Scale the model up to simulate an explosion
            const startTime = Date.now();
            const initialScale = model.scale.clone();

            function animateExplosion() {
                const elapsedTime = (Date.now() - startTime) / 1000; // Convert to seconds
                const scale = Math.min(elapsedTime / explosionDuration, 1); // Animate over time
                model.scale.set(
                    initialScale.x * (1 + scaleFactor * scale),
                    initialScale.y * (1 + scaleFactor * scale),
                    initialScale.z * (1 + scaleFactor * scale)
                );

                if (elapsedTime < explosionDuration) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    // Optionally, remove the model after explosion
                    scene.remove(model);
                }
            }

            animateExplosion();
        }

        // Camera position
        camera.position.z = 5;

        // Add orbit controls to the camera
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls for smooth camera movement

            renderer.render(scene, camera);
        }
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
