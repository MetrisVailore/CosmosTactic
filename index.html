<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Scene with OBJ Models</title>
    <!-- Use ES Modules for three.js -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
        import { OBJLoader } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/OBJLoader.js';
        import { MTLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/MTLLoader.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/controls/OrbitControls.js';

        // Request fullscreen on page load (using Telegram Web App API)
        window.Telegram.WebApp.requestFullscreen();

        // Set header color for fullscreen
        window.Telegram.WebApp.setHeaderColor("#000000");

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add space background (skybox)
        const textureLoader = new THREE.TextureLoader();
        const spaceTexture = textureLoader.load('space_texture.jpg'); // Use your own space texture
        scene.background = spaceTexture;

        // Lighting
        const light = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(light);

        // Load OBJ model with MTL material (for .obj and .mtl files)
        const objLoader = new OBJLoader();
        const mtlLoader = new MTLLoader();

        mtlLoader.load('VulcanDKyrClass.mtl', function(materials) {
            materials.preload();  // Preload materials
            objLoader.setMaterials(materials);
            objLoader.load('VulcanDKyrClass.obj', function(object) {
                object.scale.set(0.5, 0.5, 0.5); // Adjust scale
                object.position.set(0, 0, -5); // Position the object
                scene.add(object);

                // Trigger explosion after 5 seconds
                setTimeout(() => {
                    explodeModel(object); // Trigger explosion after 5 seconds
                }, 5000);
            });
        });

        // Explosion animation function
        function explodeModel(model) {
            const explosionDuration = 2; // Time in seconds
            const scaleFactor = 3; // How much the object scales during explosion

            // Scale the model up to simulate an explosion
            const startTime = Date.now();
            const initialScale = model.scale.clone();

            function animateExplosion() {
                const elapsedTime = (Date.now() - startTime) / 1000; // Convert to seconds
                const scale = Math.min(elapsedTime / explosionDuration, 1); // Animate over time
                model.scale.set(
                    initialScale.x * (1 + scaleFactor * scale),
                    initialScale.y * (1 + scaleFactor * scale),
                    initialScale.z * (1 + scaleFactor * scale)
                );

                if (elapsedTime < explosionDuration) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    // Optionally, remove the model after explosion
                    scene.remove(model);
                }
            }

            animateExplosion();
        }

        // Camera position
        camera.position.z = 5;

        // Add orbit controls to the camera
        const controls = new OrbitControls(camera, renderer.domElement);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls for smooth camera movement

            renderer.render(scene, camera);
        }
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
</body>
</html>
