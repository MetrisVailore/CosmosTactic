<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Scene with OBJ Models</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.119/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.119/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.119/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.119/examples/js/controls/OrbitControls.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js?8.0"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;  /* Remove scrollbars */
        }
        canvas {
            display: block;  /* Removes extra space around the canvas */
        }
    </style>
</head>
<body>
    <script>
        // Check if we are in Telegram Web App environment
        if (window.Telegram && window.Telegram.WebApp) {
            console.log("Telegram Web App detected.");

            // Request fullscreen only in Telegram Web App (if supported)
            try {
                window.Telegram.WebApp.requestFullscreen();
            } catch (error) {
                console.log("Fullscreen request failed: " + error.message);
            }

            // Set header color for Telegram Web App
            window.Telegram.WebApp.setHeaderColor("#000000");
        } else {
            console.log("Browser environment detected. No fullscreen request.");
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add space background (skybox)
        const textureLoader = new THREE.TextureLoader();
        const spaceTexture = textureLoader.load('space_texture.jpg'); // Use your own space texture
        scene.background = spaceTexture;

        // Lighting
        const light = new THREE.AmbientLight(0x404040, 2); // Soft white light
        scene.add(light);

        // Load OBJ model with MTL material (for .obj and .mtl files)
        const objLoader = new THREE.OBJLoader();
        const mtlLoader = new THREE.MTLLoader();

        let spaceship;
        mtlLoader.load('VulcanDKyrClass.mtl', function(materials) {
            materials.preload();  // Preload materials
            objLoader.setMaterials(materials);
            objLoader.load('VulcanDKyrClass.obj', function(object) {
                spaceship = object;
                spaceship.scale.set(0.5, 0.5, 0.5); // Adjust scale
                spaceship.position.set(0, 0, -5); // Position the object
                scene.add(spaceship);

                // Trigger explosion after 5 seconds
                setTimeout(() => {
                    explodeModel(spaceship); // Trigger explosion after 5 seconds
                }, 5000);
            });
        });

        // Explosion animation function
        function explodeModel(model) {
            const explosionDuration = 2; // Time in seconds
            const scaleFactor = 3; // How much the object scales during explosion
            const startTime = Date.now();
            const initialScale = model.scale.clone();

            function animateExplosion() {
                const elapsedTime = (Date.now() - startTime) / 1000; // Convert to seconds
                const scale = Math.min(elapsedTime / explosionDuration, 1); // Animate over time
                model.scale.set(
                    initialScale.x * (1 + scaleFactor * scale),
                    initialScale.y * (1 + scaleFactor * scale),
                    initialScale.z * (1 + scaleFactor * scale)
                );
                
                // Make the model glow
                model.material.emissive.set(0xff0000); // Set glowing color

                if (elapsedTime < explosionDuration) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    model.material.emissive.set(0x000000); // Stop glowing after explosion
                    // Optionally keep the object in the scene
                }
            }

            animateExplosion();
        }

        // Camera position
        camera.position.z = 5;

        // Add orbit controls to the camera
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Movement variables (for spaceship movement)
        let velocity = new THREE.Vector3(0, 0, 0);
        const speed = 0.1;  // Movement speed

        // Key handling for spaceship controls (WASD for movement, QE for vertical movement)
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w':  // Move forward
                    velocity.z = -speed;
                    break;
                case 's':  // Move backward
                    velocity.z = speed;
                    break;
                case 'a':  // Move left
                    velocity.x = -speed;
                    break;
                case 'd':  // Move right
                    velocity.x = speed;
                    break;
                case 'q':  // Move up
                    velocity.y = speed;
                    break;
                case 'e':  // Move down
                    velocity.y = -speed;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (['w', 's'].includes(event.key)) velocity.z = 0;
            if (['a', 'd'].includes(event.key)) velocity.x = 0;
            if (['q', 'e'].includes(event.key)) velocity.y = 0;
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Move the spaceship
            if (spaceship) {
                spaceship.position.add(velocity);
            }

            controls.update();  // Update controls for smooth camera movement

            renderer.render(scene, camera);
        }
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
